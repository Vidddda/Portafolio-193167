{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Datos generales","text":"<p>Bienvenido a mi p\u00e1gina. Soy David L\u00f3pez Ram\u00edrez, estudiante de ingenier\u00eda mecatr\u00f3nica.</p>"},{"location":"#datos-de-contacto","title":"Datos de contacto","text":"<ul> <li>Correo: 193167@iberopuebla.mx</li> <li>N\u00famero de tel\u00e9fono: 221 914 4377</li> </ul>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"esii_task1/","title":"\ud83d\udcd8 Activity 1 \u2014 FreeRTOS Tasks and Priorities","text":"<p>Identification, analysis, and design of logical tasks using FreeRTOS concepts.</p>"},{"location":"esii_task1/#1-overview","title":"1) Overview","text":"<ul> <li>Topic: Task identification, priorities, and system design with FreeRTOS</li> <li>Author: David L\u00f3pez Ram\u00edrez</li> <li>Course / Subject: Embedded Systems II </li> </ul>"},{"location":"esii_task1/#2-activities","title":"2) Activities","text":""},{"location":"esii_task1/#21-exercise-1-identify-logical-tasks","title":"2.1) Exercise 1 \u2014 Identify Logical Tasks","text":"Task Trigger (Time / Event) Periodic / Event-Based Reads a temperature sensor every 50 ms 50 ms timer Periodic Sends sensor data via Wi-Fi every 2 s 2 s timer Periodic Monitors an emergency button Button press Event-Based Blinks a status LED at 1 Hz Timer (1 s) Periodic Stores error messages when failures occur Error event Event-Based"},{"location":"esii_task1/#22-exercise-2-task-characteristics","title":"2.2) Exercise 2 \u2014 Task Characteristics","text":"Is it time-critical? (Yes / No) Can it block safely? (Yes / No) What happens if this task is delayed? No Yes It depends on the system; however, in general, the sensor would read the information at the end. No No If it takes a while, it would send the data, but if it gets blocked, it could affect communication. Yes No It would cause an accident. No Yes The LED just looks weird. No Yes Only data is lost."},{"location":"esii_task1/#23-exercise-3-priority-reasoning","title":"2.3) Exercise 3 \u2014 Priority Reasoning","text":"Task Name Priority (H / M / L) Justification Temperature Medium It is important for system operation, but small delays are acceptable. Wi-Fi Medium Communication is necessary, but short delays do not compromise safety. Emergency button High It is safety-critical and must be handled immediately. LED Low It is only visual feedback and not functionally critical. Error messages Low Logging is useful but not urgent compared to control or safety tasks."},{"location":"esii_task1/#24-exercise-4-design-judgment","title":"2.4) Exercise 4 \u2014 Design Judgment","text":"Component Type Period / Trigger Priority Description Emergency Button Interrupt (ISR) Button press \u2014 Triggers ISR, no heavy processing. SafetyTask Task Notification High Executes emergency shutdown procedures. TempTask Task 50 ms Medium Periodic sensor reading. WifiTask Task 2 s Medium Sends data without blocking other tasks. LedTask Task 1 s (1 Hz) Low Visual status indication. LogTask Task Error event Low Stores logs asynchronously."},{"location":"esii_task2/","title":"Session 2 \u2014 RTOS Basics: Tasks, Queues, and Mutex","text":"<p>Implement basic FreeRTOS multitasking concepts in ESP-IDF using tasks, queues, and mutex protection.</p>"},{"location":"esii_task2/#1-activity-goals","title":"1) Activity Goals","text":"<ul> <li>Implement multiple FreeRTOS tasks running concurrently.</li> <li>Validate task scheduling using <code>vTaskDelay()</code>.</li> <li>Pass data between tasks using a queue (producer/consumer).</li> <li>Demonstrate a race condition and fix it using a mutex.</li> <li>Document evidence with console logs, screenshots, and videos.</li> </ul>"},{"location":"esii_task2/#2-materials-setup","title":"2) Materials &amp; Setup","text":""},{"location":"esii_task2/#bom-bill-of-materials","title":"BOM (Bill of Materials)","text":"# Item Qty Link/Source Cost (MXN) Notes 1 ESP32 Board 1 Local Store / Amazon / MercadoLibre 365 Main development board 2 LED 1 Local electronics store 3 Status LED connected to GPIO 8"},{"location":"esii_task2/#toolssoftware","title":"Tools/Software","text":"<ul> <li>Framework: ESP-IDF + FreeRTOS  </li> </ul>"},{"location":"esii_task2/#lab-1-two-tasks-delays-and-priorities","title":"Lab 1 \u2014 Two Tasks, Delays, and Priorities","text":"<p>Run two tasks at the same time: one blinking an LED and one printing a message.</p>"},{"location":"esii_task2/#3-procedure-what-you-did","title":"3) Procedure (what you did)","text":"<ol> <li>Created two FreeRTOS tasks (<code>blink_task</code> and <code>hello_task</code>).</li> <li>Verified LED blinking every 300 ms.</li> <li>Verified console prints every 1 second.</li> <li>Modified task priority.</li> <li>Removed delay to observe starvation behavior.</li> </ol>"},{"location":"esii_task2/#4-data-tests-evidence","title":"4) Data, Tests &amp; Evidence","text":""},{"location":"esii_task2/#evidence-console-output","title":"Evidence (Console Output)","text":""},{"location":"esii_task2/#evidence-led-blinking","title":"Evidence (LED Blinking)","text":""},{"location":"esii_task2/#6-code","title":"6) Code","text":""},{"location":"esii_task2/#code-lab-1","title":"Code (Lab 1)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_8   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"esii_task2/#5-analysis-exercises","title":"5) Analysis (Exercises)","text":""},{"location":"esii_task2/#exercise-1-priority-experiment","title":"Exercise 1 \u2014 Priority Experiment","text":"<p>Change <code>hello_task</code> priority from 5 to 2:</p> <pre><code>xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 2, NULL);\n</code></pre>"},{"location":"esii_task2/#does-behavior-change-why-might-it-or-might-it-not","title":"Does behavior change? Why might it (or might it not)?","text":"<p>NO, because it doesn\u2019t affect the blink time of the LED. Both tasks use <code>vTaskDelay()</code>, so they block and allow the CPU to run other tasks.</p>"},{"location":"esii_task2/#evidence","title":"Evidence","text":""},{"location":"esii_task2/#exercise-2-starvation-demo","title":"Exercise 2 \u2014 Starvation Demo","text":"<p>Temporarily remove this line from <code>hello_task</code>:</p> <pre><code>vTaskDelay(pdMS_TO_TICKS(1000));\n</code></pre>"},{"location":"esii_task2/#what-happens-to-blinking","title":"What happens to blinking?","text":"<p>The LED blinking looks almost the same or does not show a clear difference. This is because FreeRTOS still schedules <code>blink_task</code> even if <code>hello_task</code> has no delay. However, <code>hello_task</code> uses much more CPU and can reduce system responsiveness.</p>"},{"location":"esii_task2/#evidence_1","title":"Evidence","text":""},{"location":"esii_task2/#exercise-3-put-the-delay-back-and-explain-in-one-sentence-why-blocking-helps","title":"Exercise 3 \u2014 Put the delay back and explain in one sentence why blocking helps","text":"<p>Blocking helps because <code>vTaskDelay()</code> puts the task in a blocked state and frees the CPU so other tasks can run.</p>"},{"location":"esii_task2/#lab-2-queue-producer-consumer","title":"Lab 2 \u2014 Queue (Producer / Consumer)","text":"<p>Send integers from a producer task to a consumer task using a FreeRTOS queue.</p>"},{"location":"esii_task2/#3-procedure-what-you-did_1","title":"3) Procedure (what you did)","text":"<ol> <li>Created a queue using <code>xQueueCreate</code>.</li> <li>Implemented a producer task to send integers to the queue.</li> <li>Implemented a consumer task to receive integers from the queue.</li> <li>Modified producer speed.</li> <li>Increased queue length.</li> <li>Made the consumer slower.</li> </ol>"},{"location":"esii_task2/#4-data-tests-evidence_1","title":"4) Data, Tests &amp; Evidence","text":""},{"location":"esii_task2/#evidence_2","title":"Evidence","text":""},{"location":"esii_task2/#6-code_1","title":"6) Code","text":""},{"location":"esii_task2/#code-lab-2","title":"Code (Lab 2)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(5, sizeof(int)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"esii_task2/#5-analysis-exercises_1","title":"5) Analysis (Exercises)","text":""},{"location":"esii_task2/#exercise-1-make-the-producer-faster-change-producer-delay-200ms-20ms","title":"Exercise 1 \u2014 Make the producer faster: change producer delay 200ms \u2192 20ms","text":"<pre><code>vTaskDelay(pdMS_TO_TICKS(20));\n</code></pre>"},{"location":"esii_task2/#exercise-2-when-do-you-see-queue-full","title":"Exercise 2 \u2014 When do you see \u201cQueue full\u201d?","text":"<p>Never. This happens because the consumer receives data fast enough to keep the queue from filling, so the producer is always able to send values successfully.</p>"},{"location":"esii_task2/#evidence_3","title":"Evidence","text":""},{"location":"esii_task2/#exercise-3-increase-the-queue-length-5-20","title":"Exercise 3 \u2014 Increase the queue length 5 \u2192 20","text":"<pre><code>q_numbers = xQueueCreate(20, sizeof(int));\n</code></pre>"},{"location":"esii_task2/#exercise-4-what-changes","title":"Exercise 4 \u2014 What changes?","text":"<p>The queue can store more values, so \"Queue full\" happens less often or takes longer to appear.</p>"},{"location":"esii_task2/#evidence_4","title":"Evidence","text":""},{"location":"esii_task2/#exercise-5-make-the-consumer-slow-after-a-successful-receive-add","title":"Exercise 5 \u2014 Make the consumer \u201cslow\u201d: after a successful receive, add:","text":"<pre><code>vTaskDelay(pdMS_TO_TICKS(300));\n</code></pre>"},{"location":"esii_task2/#exercise-6-what-pattern-is-happening-now-buffering-backlog","title":"Exercise 6 \u2014 What pattern is happening now (buffering / backlog)?","text":"<p>The queue stores values temporarily, then it fills up and the producer starts dropping values because there is no more space.</p>"},{"location":"esii_task2/#evidence_5","title":"Evidence","text":""},{"location":"esii_task2/#lab-3-mutex-protect-a-shared-resource","title":"Lab 3 \u2014 Mutex: Protect a Shared Resource","text":"<p>Demonstrate a race condition with a shared counter and fix it using a mutex.</p>"},{"location":"esii_task2/#3-procedure-what-you-did_2","title":"3) Procedure (what you did)","text":"<ol> <li>Implemented two tasks that increment a shared counter.</li> <li>Ran the program without mutex to observe race conditions.</li> <li>Added a mutex to protect the shared counter.</li> <li>Removed the mutex again to confirm weird behavior.</li> <li>Changed task priorities and observed scheduling effects.</li> </ol>"},{"location":"esii_task2/#6-code_2","title":"6) Code","text":""},{"location":"esii_task2/#part-a-race-demo-no-mutex","title":"Part A \u2014 Race demo (no mutex)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3A\";\n\nstatic volatile int shared_counter = 0;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        // NOT safe: read-modify-write without protection\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre>"},{"location":"esii_task2/#5-analysis-exercises_2","title":"5) Analysis (Exercises)","text":""},{"location":"esii_task2/#part-a-race-demo-no-mutex_1","title":"Part A \u2014 Race demo (no mutex)","text":""},{"location":"esii_task2/#question","title":"Question","text":"<p>Why can the counter be wrong?</p>"},{"location":"esii_task2/#answer","title":"Answer","text":"<p>The counter may be faulty because both tasks read the same value and overwrite it, losing increments.</p>"},{"location":"esii_task2/#evidence_6","title":"Evidence","text":""},{"location":"esii_task2/#6-code_3","title":"6) Code","text":""},{"location":"esii_task2/#part-b-fix-with-a-mutex","title":"Part B \u2014 Fix with a mutex","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3B\";\n\nstatic volatile int shared_counter = 0;\nstatic SemaphoreHandle_t counter_mutex;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        xSemaphoreTake(counter_mutex, portMAX_DELAY);\n\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        xSemaphoreGive(counter_mutex);\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3B (mutex fix)\");\n\n    counter_mutex = xSemaphoreCreateMutex();\n    if (counter_mutex == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre>"},{"location":"esii_task2/#exercise-1-remove-the-mutex-again","title":"Exercise 1 \u2014 Remove the mutex again","text":""},{"location":"esii_task2/#question_1","title":"Question","text":"<p>Do you ever see weird behavior?</p>"},{"location":"esii_task2/#answer_1","title":"Answer","text":"<p>Yes, sometimes the counter increases slower than expected or skips values.</p>"},{"location":"esii_task2/#evidence_7","title":"Evidence","text":""},{"location":"esii_task2/#exercise-2-change-priorities-taska-6-taskb-4","title":"Exercise 2 \u2014 Change priorities (TaskA = 6, TaskB = 4)","text":""},{"location":"esii_task2/#question_2","title":"Question","text":"<p>What do you expect and why?</p>"},{"location":"esii_task2/#answer_2","title":"Answer","text":"<p>TaskA (priority 6) will run more often than TaskB (priority 4). TaskA will usually print more messages because it gets CPU time first when both tasks are ready.</p>"},{"location":"esii_task2/#evidence_8","title":"Evidence","text":""},{"location":"esii_task2/#exercise-3-one-sentence","title":"Exercise 3 \u2014 One sentence","text":""},{"location":"esii_task2/#question_3","title":"Question","text":"<p>In one sentence: what does a mutex \u201cguarantee\u201d?</p>"},{"location":"esii_task2/#answer_3","title":"Answer","text":"<p>A mutex guarantees that only one task at a time can access the shared resource, preventing race conditions.</p>"},{"location":"esii_task3/","title":"Session 3 \u2014 FreeRTOS Tasks, Queues, and Mutex","text":"<p>Implement multiple FreeRTOS tasks in ESP-IDF, including heartbeat, alive logs, queue communication, mutex protection, and error logging.</p>"},{"location":"esii_task3/#1-activity-goals","title":"1) Activity Goals","text":"<ul> <li>Implement Task 1 (Heartbeat LED)</li> <li>Implement Task 2 (Alive task every 2 seconds)</li> <li>Implement Task 3 (Queue Struct Send)</li> <li>Implement Task 4 (Queue Struct Receive)</li> <li>Implement Task 5 (Mutex protected button reading)</li> <li>Implement Task 6 (Second mutex protected button task)</li> <li>Implement Task 7 (Error logging system)</li> </ul>"},{"location":"esii_task3/#2-materials-setup","title":"2) Materials &amp; Setup","text":""},{"location":"esii_task3/#bom-bill-of-materials","title":"BOM (Bill of Materials)","text":"# Item Qty Link/Source Cost (MXN) Notes 1 ESP32 Board 1 Local Store / Amazon / MercadoLibre 365 Main development board 2 LED 1 Local electronics store 3 Status LED connected to GPIO 8 3 Push Button 1 Local electronics store / Amazon / MercadoLibre 1.70-3.60 Button connected to GPIO ___"},{"location":"esii_task3/#toolssoftware","title":"Tools/Software","text":"<ul> <li>Framework: ESP-IDF + FreeRTOS  </li> </ul>"},{"location":"esii_task3/#3-procedure-what-you-did","title":"3) Procedure (what you did)","text":"<ol> <li>Created FreeRTOS tasks for heartbeat and alive monitoring.</li> <li>Implemented queue producer/consumer communication with structs.</li> <li>Implemented mutex protection for shared resources.</li> <li>Implemented error logging system.</li> <li>Verified correct execution using serial monitor output and LED behavior.</li> </ol>"},{"location":"esii_task3/#4-evidence-console-photos-videos","title":"4) Evidence (Console, Photos, Videos)","text":""},{"location":"esii_task3/#task-without-error-logging-system","title":"Task without error logging system","text":""},{"location":"esii_task3/#task-with-error-logging-system","title":"Task with error logging system","text":""},{"location":"esii_task3/#5-code","title":"5) Code","text":""},{"location":"esii_task3/#task-with-error-logging-system_1","title":"Task with error logging system","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"driver/gpio.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\n\n#define LED_GPIO GPIO_NUM_8   // CHANGE for your board\n#define BUTTON_GPIO GPIO_NUM_10 // CHANGE for your board\n\nstatic const char *TAG = \"HearbeatApp\";\nvolatile bool error[7] = {false, false, false, false, false, false};\n\nstatic QueueHandle_t q_numbers;\nstatic QueueHandle_t q_errors;\nstatic SemaphoreHandle_t shared_counter;\n\nstruct DataPacket {\n    int id;\n    float value;\n};\n\nstruct ErrorStatus {\n    int task_id;\n    bool error_state;\n};\n\nstatic void button_task1(void *pvParameters)\n{\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);\n    float pressed_time = 0.0f;\n\n    while (1) {\n        bool current_state = !gpio_get_level(BUTTON_GPIO); // Active low\n        if (current_state) {\n            pressed_time += 0.05f; // Simulating time increment\n        } \n        else if (!current_state &amp;&amp; pressed_time &gt; 0.0f) {\n            ESP_LOGI(TAG, \"Button 1 pressed for %f seconds\", pressed_time);\n\n            struct ErrorStatus status = {5, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n\n            pressed_time = 0.0f;\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(50)); // Polling delay\n    }\n}\n\nstatic void button_task2(void *pvParameters)\n{\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);\n    float pressed_time = 0.0f;\n\n    while (1) {\n        bool current_state = !gpio_get_level(BUTTON_GPIO); // Active low\n        if (current_state) {\n            pressed_time += 0.05f; // Simulating time increment\n        }\n        else if (!current_state &amp;&amp; pressed_time &gt; 0.0f) {\n            ESP_LOGI(TAG, \"Button 2 pressed for %f seconds\", pressed_time);\n\n            struct ErrorStatus status = {6, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n\n            pressed_time = 0.0f;\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(50)); // Polling delay\n    }\n}\n\nstatic void producer_task(void *pvParameters)\n{\n    struct DataPacket packet;\n    packet.id = 0;\n    packet.value = 0.0f;\n    while (1) {\n       packet.id=rand()%1000;\n       packet.value=(float)(rand()%1000)/10.0f;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;packet, pdMS_TO_TICKS(50)) == pdPASS) {\n            struct ErrorStatus status = {3, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGI(TAG, \"Produced %d with value %f\", packet.id, packet.value);\n        } else {\n            struct ErrorStatus status = {3, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGW(TAG, \"Queue full, dropped %d with value %f\", packet.id, packet.value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n     struct DataPacket packet_recv;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;packet_recv, pdMS_TO_TICKS(1500)) == pdPASS) {\n            struct ErrorStatus status = {4, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGI(TAG, \"Consumed %d with value %f\", packet_recv.id, packet_recv.value);\n        } else {\n            struct ErrorStatus status = {4, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nstatic void heartbeat_task(void *pvParameters)\n{\n    while (1) {\n        struct ErrorStatus status = {0, true};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        ESP_LOGI(TAG, \"alive\");\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\nstatic void hearbeatLED_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        struct ErrorStatus status = {2, true};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void bpm_task(void *pvParameters){\n    while (1) {\n        struct ErrorStatus status = {1, true};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        printf(\"BPM: %d\\n\", rand()%40 + 60);\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\nstatic void error_task(void *pvParameters)\n{\n    struct ErrorStatus status;\n    while (1) {\n        if (xQueueReceive(q_errors, &amp;status, pdMS_TO_TICKS(100)) == pdPASS) {\n            if (xSemaphoreTake(shared_counter, pdMS_TO_TICKS(10)) == pdTRUE) {\n                error[status.task_id] = status.error_state;\n                if (status.error_state) {\n                    ESP_LOGE(TAG, \"Error task %d\", status.task_id);\n                }\n                xSemaphoreGive(shared_counter);\n            }\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    // Create mutex for shared resources\n    shared_counter = xSemaphoreCreateMutex();\n    if (shared_counter == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n     q_numbers = xQueueCreate(5, sizeof(struct DataPacket)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    q_errors = xQueueCreate(10, sizeof(struct ErrorStatus));\n    if (q_errors == NULL) {\n        ESP_LOGE(TAG, \"Error queue create failed\");\n        return;\n    }\n\n    xTaskCreate(error_task, \"error_task\", 2048, NULL, 0, NULL);\n    xTaskCreate(heartbeat_task, \"heartbeat\", 2048, NULL, 0, NULL);\n    xTaskCreate(bpm_task, \"bpm_task\", 2048, NULL, 1, NULL);\n    xTaskCreate(hearbeatLED_task, \"hearbeatLED_task\", 2048, NULL, 1, NULL);\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 2, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 2, NULL);\n    xTaskCreate(button_task1, \"button_task1\", 2048, NULL, 3, NULL);\n    xTaskCreate(button_task2, \"button_task2\", 2048, NULL, 3, NULL);\n\n}\n</code></pre>"},{"location":"esii_task3/#task-without-error-logging-system_1","title":"Task without error logging system","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"driver/gpio.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\n\n#define LED_GPIO GPIO_NUM_8   // CHANGE for your board\n#define BUTTON_GPIO GPIO_NUM_10 // CHANGE for your board\n\nstatic const char *TAG = \"HearbeatApp\";\nvolatile bool error[7] = {false, false, false, false, false, false};\n\nstatic QueueHandle_t q_numbers;\nstatic QueueHandle_t q_errors;\nstatic SemaphoreHandle_t shared_counter;\n\nstruct DataPacket {\n    int id;\n    float value;\n};\n\nstruct ErrorStatus {\n    int task_id;\n    bool error_state;\n};\n\nstatic void button_task1(void *pvParameters)\n{\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);\n    float pressed_time = 0.0f;\n\n    while (1) {\n        bool current_state = !gpio_get_level(BUTTON_GPIO); // Active low\n        if (current_state) {\n            pressed_time += 0.05f; // Simulating time increment\n        } \n        else if (!current_state &amp;&amp; pressed_time &gt; 0.0f) {\n            ESP_LOGI(TAG, \"Button 1 pressed for %f seconds\", pressed_time);\n\n            struct ErrorStatus status = {5, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n\n            pressed_time = 0.0f;\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(50)); // Polling delay\n    }\n}\n\nstatic void button_task2(void *pvParameters)\n{\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);\n    float pressed_time = 0.0f;\n\n    while (1) {\n        bool current_state = !gpio_get_level(BUTTON_GPIO); // Active low\n        if (current_state) {\n            pressed_time += 0.05f; // Simulating time increment\n        }\n        else if (!current_state &amp;&amp; pressed_time &gt; 0.0f) {\n            ESP_LOGI(TAG, \"Button 2 pressed for %f seconds\", pressed_time);\n\n            struct ErrorStatus status = {6, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n\n            pressed_time = 0.0f;\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(50)); // Polling delay\n    }\n}\n\nstatic void producer_task(void *pvParameters)\n{\n    struct DataPacket packet;\n    packet.id = 0;\n    packet.value = 0.0f;\n    while (1) {\n       packet.id=rand()%1000;\n       packet.value=(float)(rand()%1000)/10.0f;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;packet, pdMS_TO_TICKS(50)) == pdPASS) {\n            struct ErrorStatus status = {3, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGI(TAG, \"Produced %d with value %f\", packet.id, packet.value);\n        } else {\n            struct ErrorStatus status = {3, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGW(TAG, \"Queue full, dropped %d with value %f\", packet.id, packet.value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n     struct DataPacket packet_recv;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;packet_recv, pdMS_TO_TICKS(1500)) == pdPASS) {\n            struct ErrorStatus status = {4, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGI(TAG, \"Consumed %d with value %f\", packet_recv.id, packet_recv.value);\n        } else {\n            struct ErrorStatus status = {4, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nstatic void heartbeat_task(void *pvParameters)\n{\n    while (1) {\n        struct ErrorStatus status = {0, false};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        ESP_LOGI(TAG, \"alive\");\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\nstatic void hearbeatLED_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        struct ErrorStatus status = {2, false};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void bpm_task(void *pvParameters){\n    while (1) {\n        struct ErrorStatus status = {1, false};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        printf(\"BPM: %d\\n\", rand()%40 + 60);\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\nstatic void error_task(void *pvParameters)\n{\n    struct ErrorStatus status;\n    while (1) {\n        if (xQueueReceive(q_errors, &amp;status, pdMS_TO_TICKS(100)) == pdPASS) {\n            if (xSemaphoreTake(shared_counter, pdMS_TO_TICKS(10)) == pdTRUE) {\n                error[status.task_id] = status.error_state;\n                xSemaphoreGive(shared_counter);\n            }\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    // Create mutex for shared resources\n    shared_counter = xSemaphoreCreateMutex();\n    if (shared_counter == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n     q_numbers = xQueueCreate(5, sizeof(struct DataPacket)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    q_errors = xQueueCreate(10, sizeof(struct ErrorStatus));\n    if (q_errors == NULL) {\n        ESP_LOGE(TAG, \"Error queue create failed\");\n        return;\n    }\n\n    xTaskCreate(error_task, \"error_task\", 2048, NULL, 0, NULL);\n    xTaskCreate(heartbeat_task, \"heartbeat\", 2048, NULL, 0, NULL);\n    xTaskCreate(bpm_task, \"bpm_task\", 2048, NULL, 1, NULL);\n    xTaskCreate(hearbeatLED_task, \"hearbeatLED_task\", 2048, NULL, 1, NULL);\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 2, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 2, NULL);\n    xTaskCreate(button_task1, \"button_task1\", 2048, NULL, 3, NULL);\n    xTaskCreate(button_task2, \"button_task2\", 2048, NULL, 3, NULL);\n\n}\n</code></pre>"},{"location":"esii_task3/#6-files-media","title":"6) Files &amp; Media","text":"<ul> <li>Firmware file: Descargar main.c</li> <li>Videos: <ol> <li>Task without error logging system</li> <li>Task with error logging system</li> </ol> </li> </ul>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"tarea_1/","title":"Comparaci\u00f3n de microcontroladores","text":""},{"location":"tarea_1/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre de la actividad: Comparaci\u00f3n de microcontroladores</li> <li>Autor: David L\u00f3pez Ram\u00edrez </li> <li>Curso: Sistemas Embebidos I</li> <li>Fecha: 25/08/2025 </li> <li>Descripci\u00f3n breve: Los microcontroladores son dispositivos que integran CPU, memoria y perif\u00e9ricos, dise\u00f1ados para controlar sistemas embebidos. Cuentan con RAM para datos temporales y Flash para almacenar programas de forma permanente. Entre sus perif\u00e9ricos destacan temporizadores, conversores ADC y m\u00f3dulos de comunicaci\u00f3n como UART o I2C. Pueden ser de 8, 16 o 32 bits, con frecuencias que determinan su rendimiento. Su costo y disponibilidad var\u00edan, desde opciones econ\u00f3micas para prototipos hasta modelos avanzados para aplicaciones profesionales.</li> </ul>"},{"location":"tarea_1/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comparar los diferentes microcontroladores, destacando el uso de cada uno de ellos para un \u00e1rea aplicable</li> </ul>"},{"location":"tarea_1/#3-desarrollo","title":"3) Desarrollo","text":"Microcontrolador STM32F411 Raspberry Pi Pico 2 Teensy 4.0 ATTINY85-20PU Perifer\u00edcos Cortex-M4 @ 100\u202fMHz; USB OTG FS; UART \u00d7\u202f3; SPI \u00d7\u202f5; I\u00b2C \u00d7\u202f3; I\u00b2S \u00d7\u202f5 (2 full-duplex); CAN \u00d7\u202f3 (1 con CAN FD); 11 Timers (6 de 16 bits, 2 de 32 bits, 1 PWM); ADC de 12 bits; RTC; DMA \u00d7\u202f32; Criptograf\u00eda acelerada; Batch Acquisition Mode (BAM); Flexibility Matrix para interconexi\u00f3n de perif\u00e9ricos Timers de 8 bits con 4 alarmas + AON Timer; UART \u00d7 2; SPI \u00d7 2; I\u00b2C \u00d7 2; PWM \u00d7 24 canales; USB 1.1 (host/dev); ADC 12 bits; PIO \u00d7 3 (12 state machines); sensor de temperatura Pines: 40 digitales, 31 PMW, 14 anal\u00f3gicos; Puertos: 7 serial, 3 SPI, 3 I2C; Puertos de audio: 2 I2S/TDM, 1 S/DIF; Buses: 3 CAN (1 CAN FD); 32 canales DMA; Aceleraci\u00f3n criptogr\u00e1fica y generador de n\u00fameros aleatorios; RTC para fecha/hora; FlexIO programable Timers 8 bits + PWM; PWM alta frecuencia; USI; ADC 10 bits (single/diferencial); Watchdog; Comparador anal\u00f3gico Memoria Flash: 512 KB/RAM: 128 KB RAM: 4 MB/SRAM: 520 KB Flash: 1984 KB/RAM: 1024 KB/EEPROM: 1 KB/Cach\u00e9: 32 KB Flash: 8 KB/SRAM: 512 B/EEPROM: 512 B Ecosistema STM32CubeIDE; Keil MDK; IAR Embedded Workbench; PlatformIO; GCC ARM; STM32CubeMX; HAL/LL; Middleware USB/TCP/IP/FATFS/FreeRTOS; ST-Link; SWD/JTAG; Nucleo/Discovery; FreeRTOS/Zephyr/Mbed OS Raspberry Pi SDK (C/C++); MicroPython; Thonny IDE; Visual Studio Code/PlatformIO; USB Bootloader integrado; SWD Debug Arduino IDE + Teensyduino; Visual Micro; PlatformIO; CircuitPython; L\u00ednea de comandos con Makefile AVR-GCC; Assembly AVR; Core de Arduino; AVRISP mkII; USBasp; TinyUSB Costos \\(98MXN-\\)104MXN \\(118.10MXN-\\)302.29MXN \\(614.57MXN-\\)1165MXN \\(87MXN-\\)110MXN Arquitectura ARM Cortex-M4(RISC) Dual Cortex-M33/Hazard3 ARM Cortex-M7 RISC Velocidad de trabajo 100 MHz 150 MHz 600 MHz 20 MHz"},{"location":"tarea_1/#raking-de-microcontroladores-para-micromouse","title":"Raking de microcontroladores para micromouse","text":""},{"location":"tarea_1/#1-raspberry-pi-pico-2","title":"1) Raspberry Pi Pico 2","text":"<ul> <li> <p>Ventajas: </p> <ul> <li>150 MHz dual-core, 512 KB RAM.</li> <li>F\u00e1cil de programar (C/C++ o MicroPython).</li> <li>Muy barato y accesible.</li> </ul> </li> <li> <p>Desventajas: </p> <ul> <li>FPU menos avanzado.</li> <li>Perif\u00e9ricos menos potentes que STM32.</li> </ul> </li> </ul>"},{"location":"tarea_1/#2-stm32f411","title":"2) STM32F411","text":"<ul> <li> <p>Ventajas: </p> <ul> <li>100 MHz, ARM Cortex-M4 con FPU.</li> <li>ADC r\u00e1pidos, timers avanzados, perif\u00e9ricos completos.</li> <li>Ecosistema profesional.</li> </ul> </li> <li> <p>Desventajas: </p> <ul> <li>Programaci\u00f3n m\u00e1s compleja.</li> <li>Requiere programador externo.</li> </ul> </li> </ul>"},{"location":"tarea_1/#3-teensy-40","title":"3) Teensy 4.0","text":"<ul> <li> <p>Ventajas: </p> <ul> <li>600 MHz, ARM Cortex-M7, FPU y DSP.</li> <li>Enorme potencia de c\u00e1lculo.</li> <li>Diversas opciones de programaci\u00f3n.</li> </ul> </li> <li> <p>Desventajas: </p> <ul> <li>Caro.</li> <li>Mucha potencia para un micromouse.</li> <li>Mayor consumo.</li> </ul> </li> </ul>"},{"location":"tarea_1/#4-attiny85-20pu","title":"4) ATtiny85-20PU","text":"<ul> <li> <p>Ventajas: </p> <ul> <li>Barato y sencillo.</li> <li>Bajo consumo.</li> </ul> </li> <li> <p>Desventajas: </p> <ul> <li>Solo 20 MHz, 512 B RAM.</li> <li>Muy limitado en sensores, control y algoritmos.</li> </ul> </li> </ul>"},{"location":"tarea_1/#4-referencias","title":"4) Referencias","text":"<p>\u201cTeensy\u00ae 4.0\u201d. PJRC: Electronic Projects. Accedido el 27 de agosto de 2025. [En l\u00ednea]. Disponible: https://www.pjrc.com/store/teensy40.html</p> <p>\u201cAttiny85-20pu pdf\u201d. ALLDATASHEET.COM - Electronic Parts Datasheet Search. Accedido el 27 de agosto de 2025. [En l\u00ednea]. Disponible: https://www.alldatasheet.com/datasheet-pdf/view/163120/ATMEL/ATTINY85-20PU.html</p> <p>Raspberry Pi Datasheets. Accedido el 27 de agosto de 2025. [En l\u00ednea]. Disponible: https://datasheets.raspberrypi.com/pico/pico-2-datasheet.pdf</p> <p>\u201cStm32f411 pdf\u201d. ALLDATASHEET.COM - Electronic Parts Datasheet Search. Accedido el 27 de agosto de 2025. [En l\u00ednea]. Disponible: https://www.alldatasheet.com/datasheet-pdf/view/1179070/STMICROELECTRONICS/STM32F411.html</p>"},{"location":"tarea_2/","title":"Outpus b\u00e1sicos","text":""},{"location":"tarea_2/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Outputs b\u00e1sicos </li> <li>Equipo: Carlos Ernesto Camacho Gonzalez y David L\u00f3pez Ram\u00edrez </li> <li>Curso: Sistemas Embebidos I </li> <li>Fecha: 29/08/2025 </li> <li>Descripci\u00f3n breve: Introducci\u00f3n a la programaci\u00f3n de salidas para el microcontrolador Raspberry Pi Pico 2 RP2350. Se presentan tres c\u00f3digos b\u00e1sicos para mejorar la comprensi\u00f3n de las s\u00e1lidas, las cuales son representadas por los LEDs.</li> </ul>"},{"location":"tarea_2/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender la programaci\u00f3n b\u00e1sica para la configuraci\u00f3n de s\u00e1lidas.</li> <li>Espec\u00edficos:</li> <li>Entender las funciones de b\u00e1sicas de programaci\u00f3n en C para establecer s\u00e1lidas</li> </ul>"},{"location":"tarea_2/#3-requisitos","title":"3) Requisitos","text":"<p>Software - Visual Studio Code (Lenguaje de programaci\u00f3n C)</p> <p>Hardware - Raspberry Pi Pico 2 RP2350</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica</p>"},{"location":"tarea_2/#4-desarrollo","title":"4) Desarrollo","text":""},{"location":"tarea_2/#1-contador-binario-4-bits","title":"1)  Contador binario 4 bits","text":""},{"location":"tarea_2/#funcion","title":"Funci\u00f3n","text":"<p>El contador binario de 4 bits aprovecha la lectura del Visual Studio Code al ingresar n\u00fameros decimales y convertirlos autom\u00e1ticamente a binario, de manera que existen cuatro salidas representadas con un LED cada una.  El c\u00f3digo logra que enciendan los LEDs correspondientes al n\u00famero decimal para representarlo en binario.</p>"},{"location":"tarea_2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n//Define los pines.\n\n#define A   0 \n#define B   1\n#define C   2\n#define D   3\n\nint main() {\n    //Crea la m\u00e1scara con un valor inicial 1.\n    const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D); \n\n    gpio_init_mask(MASK); //Inicializa los pines de la m\u00e1scara.\n    gpio_set_dir_masked(MASK, MASK); //Establece los pines como salida.\n\n    while (true) {\n        for (uint8_t i = 0; i &lt; 16; i++) {\n            gpio_put_masked(MASK, i &lt;&lt; A); //Envia la salida a \"MASK\" representando el valor \"i\" a la posici\u00f3n \"A\".\n            sleep_ms(500);                 \n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre>"},{"location":"tarea_2/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_2/#video","title":"V\u00eddeo","text":""},{"location":"tarea_2/#2-barrido-de-leds","title":"2) Barrido de LEDs","text":""},{"location":"tarea_2/#funcion_1","title":"Funci\u00f3n","text":"<p>El barrido de LEDs se realiza mediante una m\u00e1scara, la cu\u00e1l se limpia con cada iteraci\u00f3n del bucle \"for\" y se establece un valor \"1\" en la posici\u00f3n deseada, yendo desde la posici\u00f3n \"0\" hasta la posici\u00f3n \"4\".</p> <pre><code>#include \"pico/stdli-b.h\"\n#include \"hardware/gpio.h\"\n\n//Declaraci\u00f3n de pines.\n\n#define A 0   \n#define B 1   \n#define C 2   \n#define D 3 \n#define E 4  \n\nint main() {\n    //Construcci\u00f3n de la m\u00e1scara.\n    const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D) | (1u&lt;&lt;E);\n\n    gpio_init_mask(MASK); //Inicializa los pines de la m\u00e1scara.\n    gpio_set_dir_out_masked(MASK); //Establece los pines de la m\u00e1scara como salida.\n    gpio_clr_mask(MASK); //Limpia la m\u00e1scara.\n\n    while (true) {\n\n        for (uint8_t i = 0; i &lt; 5; ++i) {\n            gpio_clr_mask(MASK); // Limpia la m\u00e1scara.\n            gpio_set_mask(1 &lt;&lt; i); //Establece un valor \"1\" en la posici\u00f3n del bit \"i\".\n            sleep_ms(300);\n        }\n\n        for (uint8_t i = 3; i &gt; 0; --i) {\n            gpio_clr_mask(MASK); // Limpia la m\u00e1scara.\n            gpio_set_mask(1 &lt;&lt; i); //Establece un valor \"1\" en la posici\u00f3n del bit \"i\".\n            sleep_ms(300);\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}}\n</code></pre> <p>Nota</p> <p>Para optimizar el uso de la memoria se establece i = 3, debido a que el bucle anterior se finaliza con la posici\u00f3n \"4\" con el LED encendido, de la misma manera se evito poner \"i &gt;= 0\" por el mismo motivo.</p> <pre><code>for (int i = 3; i &gt; 0; --i)\n</code></pre>"},{"location":"tarea_2/#esquematico-de-conexion_1","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_2/#video_1","title":"V\u00eddeo","text":""},{"location":"tarea_2/#3-secuencia-en-codigo-gray","title":"3) Secuencia en c\u00f3digo Gray","text":""},{"location":"tarea_2/#funcion_2","title":"Funci\u00f3n","text":"<p>El siguiente c\u00f3digo simula la Secuencia de Gray mediante el uso de una funci\u00f3n que se encarga de convertir los n\u00fameros. De tal manera que, dicha secuencia se mostrar\u00e1 en la s\u00e1lida de tres LEDs que simulan cada bit.</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n//Declara los pines.\n\n#define A 0\n#define B 1\n#define C 2\n\n//Establece la funci\u00f3n para convertir de binario a secuencia de Gray.\n\nuint8_t bin_gray(uint8_t num_dec) {\n    return num_dec ^ (num_dec &gt;&gt; 1); //Recibe un n\u00famero decimal y regresa la operaci\u00f3n XOR de \"num_dec\" con \"num_dec\" en binario desplazado hacia la derecha una posici\u00f3n. \n}\n\nint main() {\n    //Crea la m\u00e1scara.\n    const uint8_t MASK = (1u &lt;&lt; A) | (1u &lt;&lt; B) | (1u &lt;&lt; C);\n\n    gpio_init_mask(MASK); //Inicializa los pines de la m\u00e1scara.\n    gpio_set_dir_masked(MASK, MASK); //Establece los pines como salida.\n\n    while (true) {\n        for (uint8_t i = 0; i &lt; 8; i++) {\n            uint8_t gray = bin_gray(i); //Toma el valor de la funci\u00f3n \"bin_gray(i)\", donde \"i\" reemplaza el lugar de \"num_dec\".\n            gpio_put_masked(MASK, gray); //Coloca los valores de \"gray\" en \"MASK\".\n            sleep_ms(500);\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre>"},{"location":"tarea_2/#esquematico-de-conexion_2","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_2/#video_2","title":"V\u00eddeo","text":""},{"location":"tarea_3/","title":"Inputs","text":""},{"location":"tarea_3/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Inputs </li> <li>Equipo: Carlos Ernesto Camacho Gonzalez y David L\u00f3pez Ram\u00edrez </li> <li>Curso: Sistemas Embebidos I </li> <li>Fecha: 01/09/2025 </li> <li>Descripci\u00f3n breve: Introducci\u00f3n a la programaci\u00f3n de entradas para el microcontrolador Raspberry Pi Pico 2 RP2350. Se presentan dos c\u00f3digos b\u00e1sicos que leen botones para representar salidas en forma de LEDs.</li> </ul>"},{"location":"tarea_3/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender la programaci\u00f3n b\u00e1sica para la configuraci\u00f3n de entradas.</li> <li>Espec\u00edficos:</li> <li>Entender las funciones de b\u00e1sicas de programaci\u00f3n en C para establecer entradas.</li> </ul>"},{"location":"tarea_3/#3-requisitos","title":"3) Requisitos","text":"<p>Software - Visual Studio Code (Lenguaje de programaci\u00f3n C)</p> <p>Hardware - Raspberry Pi Pico 2 RP2350</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica</p>"},{"location":"tarea_3/#4-desarrollo","title":"4) Desarrollo","text":""},{"location":"tarea_3/#1-compuertas-basicas-and-or-xor-con-2-botones","title":"1)  Compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":""},{"location":"tarea_3/#funcion","title":"Funci\u00f3n","text":"<p>Con dos botones (pull-up; presionado=0) para simular cada compuerta, se encienden tres LEDs que muestran en paralelo los resultados de AND, OR y XOR. </p>"},{"location":"tarea_3/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n// Pines AND\n#define BTN_A 0      \n#define BTN_B 1    \n#define LED0   6\n// Pines OR\n#define BTN_C 2     \n#define BTN_D 3    \n#define LED1   7\n// Pines XOR\n#define BTN_E 4      \n#define BTN_F 5    \n#define LED2   8\n\nbool AND() {\n    bool A_PRESS = !gpio_get(BTN_A);\n    bool B_PRESS = !gpio_get(BTN_B);\n    return (A_PRESS &amp;&amp; B_PRESS);\n}\n\nbool OR() {\n    bool C_PRESS = !gpio_get(BTN_C);\n    bool D_PRESS = !gpio_get(BTN_D);\n    return (C_PRESS || D_PRESS);\n}\n\nbool XOR() {\n    bool E_PRESS = !gpio_get(BTN_E);\n    bool F_PRESS = !gpio_get(BTN_F);\n    return (E_PRESS ^ F_PRESS);\n}\n\nint main(void) {\n    // Inicializaci\u00f3n pines AND\n    gpio_init(LED0);\n    gpio_set_dir(LED0, GPIO_OUT);\n\n    gpio_init(BTN_A);\n    gpio_set_dir(BTN_A, GPIO_IN);\n    gpio_pull_up(BTN_A);\n\n    gpio_init(BTN_B);\n    gpio_set_dir(BTN_B, GPIO_IN);\n    gpio_pull_up(BTN_B);\n\n    // Inicializaci\u00f3n pines OR\n    gpio_init(LED1);\n    gpio_set_dir(LED1, GPIO_OUT);\n\n    gpio_init(BTN_C);\n    gpio_set_dir(BTN_C, GPIO_IN);\n    gpio_pull_up(BTN_C);\n\n    gpio_init(BTN_D);\n    gpio_set_dir(BTN_D, GPIO_IN);\n    gpio_pull_up(BTN_D);\n\n    // Inicializaci\u00f3n pines XOR\n    gpio_init(LED2);\n    gpio_set_dir(LED2, GPIO_OUT);\n\n    gpio_init(BTN_E);\n    gpio_set_dir(BTN_E, GPIO_IN);\n    gpio_pull_up(BTN_E);\n\n    gpio_init(BTN_F);\n    gpio_set_dir(BTN_F, GPIO_IN);\n    gpio_pull_up(BTN_F);\n\n    while (true) {\n        // Funci\u00f3n AND\n        if (AND())  gpio_put(LED0, 1);\n        else        gpio_put(LED0, 0);\n\n        // Funci\u00f3n OR\n        if (OR())   gpio_put(LED1, 1);\n        else        gpio_put(LED1, 0);\n\n        // Funci\u00f3n XOR\n        if (XOR())  gpio_put(LED2, 1);\n        else        gpio_put(LED2, 0);\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"tarea_3/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_3/#video","title":"V\u00eddeo","text":""},{"location":"tarea_3/#2-selector-ciclico-de-4-leds-con-avanceretroceso","title":"2) Selector c\u00edclico de 4 LEDs con avance/retroceso","text":""},{"location":"tarea_3/#funcion_1","title":"Funci\u00f3n","text":"<p>Con ayuda de dos botones (NEXT y PREVIOUS) se puede seleccionar la posici\u00f3n deseada del LED. Este inicia apagado y comienza en el primer LED (si se presiona NEXT) o en el \u00faltimo (si se presiona PREVIOUS). En caso de superar la posici\u00f3n del \u00faltimo LED, se reinicia hacia la primera posici\u00f3n o la \u00faltima (dependiendo si se presion\u00f3 NEXT o PREVIOUS). Asimismo, se implement\u00f3 un antirrebote para evitar que el c\u00edclo continue cuando se mantiene pulsado un bot\u00f3n.</p> <pre><code>#include \"pico/stdlib.h\"\n\n#define BTN_PREV 0      \n#define BTN_NEXT 1    \n#define LED0   2\n#define LED1   3\n#define LED2   4\n#define LED3   5\n\nuint8_t STATE = LED0 - 1;\n\nint main(void) {\n    const uint8_t LEDs_M = (1u &lt;&lt; LED0 | 1u &lt;&lt; LED1 | 1u &lt;&lt; LED2 | 1u &lt;&lt; LED3);\n\n    gpio_init_mask(LEDs_M);\n    gpio_set_dir_out_masked(LEDs_M);\n    gpio_set_mask(LEDs_M);   \n    gpio_clr_mask(LEDs_M);\n\n    gpio_init(BTN_PREV);\n    gpio_set_dir(BTN_PREV, GPIO_IN);\n    gpio_pull_up(BTN_PREV);\n\n    gpio_init(BTN_NEXT);\n    gpio_set_dir(BTN_NEXT, GPIO_IN);\n    gpio_pull_up(BTN_NEXT);\n\n    bool NEXT_PREVSTATE = 1;\n    bool PREV_PREVSTATE = 1;\n\n    while (true) {\n        bool NEXT_STATE = !gpio_get(BTN_NEXT);\n        bool PREV_STATE = !gpio_get(BTN_PREV);\n\n        // Siguiente LED\n        if (NEXT_STATE &amp;&amp; !NEXT_PREVSTATE) {\n            if (STATE == LED3) {\n                STATE = LED0;\n            } else {\n                STATE ++;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        // Anterior LED\n        if (PREV_STATE &amp;&amp; !PREV_PREVSTATE) {\n            if (STATE == LED0) {\n                STATE = LED3;\n            } else {\n                STATE --;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        NEXT_PREVSTATE = NEXT_STATE;\n        PREV_PREVSTATE = PREV_STATE;\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"tarea_3/#esquematico-de-conexion_1","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_3/#video_1","title":"V\u00eddeo","text":""},{"location":"tarea_4/","title":"Mini-Pong","text":""},{"location":"tarea_4/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mini-Pong </li> <li>Equipo: Carlos Ernesto Camacho Gonzalez y David L\u00f3pez Ram\u00edrez </li> <li>Curso: Sistemas Embebidos I </li> <li>Fecha: 07/09/2025 </li> <li>Descripci\u00f3n breve: Se elabora un mini-Pong para entender mejor el funcionamiento de las interrupciones.</li> </ul>"},{"location":"tarea_4/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender la programaci\u00f3n b\u00e1sica para la configuraci\u00f3n de interrupciones.</li> </ul>"},{"location":"tarea_4/#3-requisitos","title":"3) Requisitos","text":"<p>Software - Visual Studio Code (Lenguaje de programaci\u00f3n C)</p> <p>Hardware - Raspberry Pi Pico 2 RP2350</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica</p>"},{"location":"tarea_4/#4-desarrollo-del-mini-pong","title":"4) Desarrollo del Mini-Pong","text":""},{"location":"tarea_4/#funcion","title":"Funci\u00f3n","text":"<p>Se trata de un mini-Pong con 5 LEDs en l\u00ednea y 2 botones, programados como interrupciones (ISR) para simular la \"raqueta\" del jugador exactamente cuando la \"pelota\" (un LED encendido) llega al extremo de su lado.</p> <p>Reglas del juego</p> <ul> <li> <p>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (LED0\u2192LED4\u2192LED0\u2026) a un ritmo fijo.</p> </li> <li> <p>Golpe (con ISR): cada bot\u00f3n genera una interrupci\u00f3n.</p> <ul> <li> <p>El BTN_J1 solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en LED0.</p> </li> <li> <p>El BTN_J2 solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en LED4.</p> </li> <li> <p>Si coincide, la pelota rebota (invierte su direcci\u00f3n).</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> </ul> </li> <li> <p>Fallo y punto: si la pelota alcanza LED0 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza LED4 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto (LED_J1 o LED_J2).</p> </li> <li> <p>Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (LED2) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego: al encender, la pelota inicia en LED2 y no se mueve hasta que se presione un bot\u00f3n y deber\u00e1 moverse a la direccion opuesta del boton presionado.</p> </li> </ul>"},{"location":"tarea_4/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n//Definici\u00f3n de PINes\n#define BTN_J1 0   //Bot\u00f3n jugador izquierda\n#define BTN_J2 1   //Bot\u00f3n jugador derecha\n#define LED_J1 2   //LED indicador puntos J1\n#define LED_J2 3   //LED indicador puntos J2\n#define LED0 4     //Posici\u00f3n 0 de LED\n#define LED1 5\n#define LED2 6     //Centro de LEDs\n#define LED3 7\n#define LED4 8     //Posici\u00f3n 4 de LED\n#define RESET 9    //Bot\u00f3n de reinicio\n\n//Velocidades (ms)\n#define VEL_PELOTA 100\n#define VEL_REBOTE 300\n\n//Variables globales\nuint8_t POS = LED2;     //Pelota arranca en el centro\nbool DIR = 1;           //1 = derecha, 0 = izquierda\nbool START = false;     //Juego detenido al inicio\n\n//Estados de interrupci\u00f3n\nvolatile bool GOLPE_J1 = false;\nvolatile bool GOLPE_J2 = false;\nvolatile bool START_J1 = false;\nvolatile bool START_J2 = false;\nvolatile bool RESET_STATE = false;\n\n//Establece m\u00e1scara de LEDs como global\nuint32_t LEDS_MASK;\n\n//Llamada de ISR\nstatic void PONG(uint PIN, uint32_t EVENT_MASK);\n\n//Llamada de BLINK\nvoid BLINK(uint8_t LED);\n\n//Llamada de REINICIAR\nvoid REINICIAR();\n\n//Llamada de MOVER_PELOTA\nvoid MOVER_PELOTA();\n\nint main() {\n    //Inicializaci\u00f3n de LEDs\n    LEDS_MASK = (1u &lt;&lt; LED_J1) | (1u &lt;&lt; LED_J2) | (1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) |(1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4);\n\n    gpio_init_mask(LEDS_MASK);\n    gpio_set_dir_masked(LEDS_MASK, LEDS_MASK);\n    gpio_clr_mask(LEDS_MASK);\n\n    //Inicializaci\u00f3n de botones\n    gpio_init(BTN_J1);\n    gpio_set_dir(BTN_J1, GPIO_IN);\n    gpio_pull_up(BTN_J1);\n\n    gpio_init(BTN_J2);\n    gpio_set_dir(BTN_J2, GPIO_IN);\n    gpio_pull_up(BTN_J2);\n\n    gpio_init(RESET);\n    gpio_set_dir(RESET, GPIO_IN);\n    gpio_pull_up(RESET);\n\n    gpio_set_mask(1u &lt;&lt; POS); //LED inicial en centro\n\n    //Habilitar IRQ por flanco de bajada\n    gpio_set_irq_enabled_with_callback(BTN_J1, GPIO_IRQ_EDGE_FALL, true, &amp;PONG);\n    gpio_set_irq_enabled(BTN_J2, GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(RESET, GPIO_IRQ_EDGE_FALL, true);\n\n    while (true) {\n        MOVER_PELOTA();\n        sleep_ms(VEL_PELOTA);\n    }\n}\n\n//ISR: activa rebote si la pelota est\u00e1 en el extremo o inicio de juego\nstatic void PONG(uint PIN, uint32_t EVENT_MASK) {\n    if (EVENT_MASK &amp; GPIO_IRQ_EDGE_FALL) {\n        if (PIN == BTN_J1) {\n            if (!START) START_J1 = true;       //Arranque inicial\n            else if (POS == LED0) GOLPE_J1 = true; //Rebote v\u00e1lido extremo izquierdo\n        } else if (PIN == BTN_J2) {\n            if (!START) START_J2 = true;       //Arranque inicial\n            else if (POS == LED4) GOLPE_J2 = true; //Rebote v\u00e1lido extremo derecho\n        } else if (PIN == RESET) {\n            RESET_STATE = true;                   //Activar reinicio\n        }\n    }\n    gpio_acknowledge_irq(PIN, EVENT_MASK);\n}\n\nvoid BLINK(uint8_t LED) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(LED, 1);\n        sleep_ms(200);\n        gpio_put(LED, 0);\n        sleep_ms(200);\n    }\n}\n\nvoid REINICIAR() {\n    POS = LED2;\n    START = false;\n    GOLPE_J1 = false;\n    GOLPE_J2 = false;\n    START_J1 = false;\n    START_J2 = false;\n    gpio_clr_mask(LEDS_MASK);\n    gpio_set_mask(1 &lt;&lt; POS); //LED centro\n}\n\nvoid MOVER_PELOTA() {\n    //Chequear reinicio\n    if (RESET_STATE) {\n        REINICIAR();\n        RESET_STATE = false;\n        return;\n    }\n\n    //Inicio del juego\n    if (!START) {\n        if (START_J1) { \n            DIR = 1;      //Hacia la derecha (opuesto al bot\u00f3n)\n            START = true;\n            START_J1 = false;\n        } else if (START_J2) {\n            DIR = 0;      //Hacia la izquierda\n            START = true;\n            START_J2 = false;\n        }\n        gpio_set_mask(1u &lt;&lt; POS); //LED centro\n        return;\n    }\n\n    //Mover pelota\n    if (DIR &amp;&amp; POS &lt; LED4) POS++;\n    else if (!DIR &amp;&amp; POS &gt; LED0) POS--;\n\n    //Rebote o punto\n    if (POS == LED0) {\n        gpio_clr_mask(LEDS_MASK);\n        gpio_set_mask(1 &lt;&lt; POS);\n        sleep_ms(VEL_REBOTE);\n        if (GOLPE_J1) {\n            DIR = 1; //Rebote v\u00e1lido\n        } else {\n            BLINK(LED_J2); //Punto jugador derecho\n            POS = LED2;         //Reinicio al centro\n            DIR = 1;            //Direcci\u00f3n hacia jugador que anot\u00f3\n            START = true;     //Continuar movimiento autom\u00e1ticamente\n        }\n        GOLPE_J1 = false;\n    } else if (POS == LED4) {\n        gpio_clr_mask(LEDS_MASK);\n        gpio_set_mask(1 &lt;&lt; POS);\n        sleep_ms(VEL_REBOTE);\n        if (GOLPE_J2) {\n            DIR = 0; //Rebote v\u00e1lido\n        } else {\n            BLINK(LED_J1); //Punto jugador izquierdo\n            POS = LED2;         //Reinicio al centro\n            DIR = 0;            //Rirecci\u00f3n hacia jugador que anot\u00f3\n            START = true;     //Continuar movimiento autom\u00e1ticamente\n        }\n        GOLPE_J2 = false;\n    }\n\n    //Actualizar LED de pelota\n    gpio_clr_mask(LEDS_MASK);\n    gpio_set_mask(1 &lt;&lt; POS);\n}\n</code></pre> <p>Adici\u00f3n</p> <p>Se integr\u00f3 un bot\u00f3n de RESET para cuando se quiera detener el juego, de manera que la pelota se quede en el centro de la \"cancha\".</p>"},{"location":"tarea_4/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"tarea_4/#calculos-de-corriente","title":"C\u00e1lculos de corriente","text":""},{"location":"tarea_4/#caso-1-led-consume-18v","title":"Caso 1: LED consume 1.8V","text":"<p>Considerando que:</p> <p>\\(V_{GPIO} = 3.3V\\\\\\)</p> <p>\\(V_{LED} = 1.8V\\\\\\)</p> <p>\\(I_{GPIO} = 12\\,mA\\)</p> <p>Entonces:</p> <p>\\(V_{T} = 1.5V\\\\\\)</p> <p>Por lo tanto:</p> <p>\\(R_{MIN} = \\frac{V_{T}}{I_{GPIO}} = \\frac{1.5V}{12\\,mA} = 125\\Omega\\)</p> <p>Sin embargo, considerando la corriente total del I/O (3V3):</p> <p>\\(I_{I/O} = 50\\,mA\\)</p> <p>Los \\(125\\Omega\\) no son suficientes, debido a que se cuentan con 7 LEDs. Por lo tanto, la corriente m\u00e1xima que puede tener cada pin es de \\(I_{MAX} = 7.14\\,mA\\). Considerando lo anterior:</p> <p>\\(R_{MIN_{REAL_{1.8V}} } = \\frac{V_{T}}{I_{PERMITIDA}} = \\frac{1.5V}{7.14\\,mA} = 210\\Omega\\)</p>"},{"location":"tarea_4/#caso-2-led-consume-2v","title":"Caso 2: LED consume 2V","text":"<p>Por otro lado, considerando que:</p> <p>\\(V_{GPIO} = 3.3V\\\\\\)</p> <p>\\(V_{LED} = 2V\\\\\\)</p> <p>\\(I_{PERMITIDA} = 7.14\\,mA\\)</p> <p>Entonces:</p> <p>\\(R_{MIN_{REAL_{2V}} } = \\frac{V_{T}}{I_{PERMITIDA}} = \\frac{1.3V}{7.14\\,mA} = 182\\Omega\\)</p> <p>Tomando en cuenta ambos casos, para evitar forzar la corriente del I/O, se escogieron resistencias de \\(220 \\Omega\\), aunque est\u00e1s podr\u00edan incrementar para reducir el consumo de corriente.</p> <p>De manera que la corriente es:</p> <p>\\(I_{LED_{1.5V}} = \\frac{1.5V}{220} = 6.81\\,mA\\)</p> <p>\\(I_{LED_{1.3V}} = \\frac{1.3V}{220} = 5.91\\,mA\\)</p> <p>Tomando esto en cuenta, la corriente total oscila entre \\(41.37\\,mA\\) ~ \\(47.67\\,mA\\)</p>"},{"location":"tarea_4/#botones","title":"Botones","text":"<p>Considerando que la corriente restante es de \\(2.33\\,mA\\), entonces:</p> <p>\\(I_{BTNs} = 0.78\\,mA\\)</p> <p>Debido a que se cuentan con 3 botones, la resistencia min\u00edma para cada uno de ellos ser\u00eda:</p> <p>\\(R_{MIN} = \\frac{3.3V}{0.78\\,mA} = 4.23\\,k\\Omega\\)</p> <p>Sin embargo, esto forzar\u00eda al RP2350, por lo tanto, se escogi\u00f3 una resistencia de \\(10\\,k\\Omega\\). Donde la corriente ser\u00eda \\(I = 0.33\\,mA\\).</p>"},{"location":"tarea_4/#video","title":"Video","text":""},{"location":"tarea_5/","title":"Comparaci\u00f3n de alarmas","text":""},{"location":"tarea_5/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Comparaci\u00f3n de alarmas </li> <li>Equipo: Carlos Ernesto Camacho Gonzalez y David L\u00f3pez Ram\u00edrez </li> <li>Curso: Sistemas Embebidos I </li> <li>Fecha: 14/09/2025 </li> <li>Descripci\u00f3n breve: Se comparan las alarmas modo \u00b5s VS modo ciclos, mediante el uso de un osciloscopio.</li> </ul>"},{"location":"tarea_5/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comparar las alarmas en modo \u00b5s VS modo ciclos.</li> <li>Espec\u00edficos: <ul> <li>Entender la programaci\u00f3n de alarmas.</li> <li>Establecer las diferencias entre cada tipo de alarma.</li> </ul> </li> </ul>"},{"location":"tarea_5/#3-requisitos","title":"3) Requisitos","text":"<p>Software - Visual Studio Code (Lenguaje de programaci\u00f3n C)</p> <p>Hardware - Raspberry Pi Pico 2 RP2350</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica</p>"},{"location":"tarea_5/#4-desarrollo","title":"4) Desarrollo","text":"<p>Para ambos casos se utilizaron las siguientes escalas en el osciloscopio:</p> <ul> <li>Escala de tiempo: 200ms</li> <li>Escala de voltaje: 5 V</li> </ul>"},{"location":"tarea_5/#alarma-en-modo-s","title":"Alarma en modo \u00b5s","text":""},{"location":"tarea_5/#codigo","title":"C\u00f3digo","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 0\nstatic const int BLINK_MS = 1000;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre> <p>Como se puede observar en la imagen, \\(\\triangle\\) tiene un valor de 1.001 segundos, lo que indica un retardo de 0.001 segundos al momentor de accionar la alarma.</p>"},{"location":"tarea_5/#alarma-en-modo-ciclos","title":"Alarma en modo ciclos","text":""},{"location":"tarea_5/#codigo_1","title":"C\u00f3digo","text":"<pre><code>/ Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 1000000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre> <p>En este caso, \\(\\triangle\\) tiene un valor exacto de 1 segundo, por lo que no se cuenta con ning\u00fan retraso notorio. Con esto se puede observar la mayor presici\u00f3n </p>"},{"location":"tarea_6/","title":"Alarmas aplicadas","text":""},{"location":"tarea_6/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Alarmas aplicadas </li> <li>Equipo: Carlos Ernesto Camacho Gonzalez y David L\u00f3pez Ram\u00edrez </li> <li>Curso: Sistemas Embebidos I </li> <li>Fecha: 16/09/2025 </li> <li>Descripci\u00f3n breve: Se configurar\u00e1n cuatro alarmas para controlar LEDs a diferentes frecuencias y se -modificar\u00e1 el juego del Mini-Pong para ajustar su velocidad mediante botones sin usar la funci\u00f3n \"delay\".</li> </ul>"},{"location":"tarea_6/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender y aplicar el uso de temporizadores mediante la implementaci\u00f3n de alarmas.</li> <li>Espec\u00edficos:</li> <li>Configurar y utilizar cuatro alarmas para controlar LEDs a diferentes frecuencias de manera independiente.</li> <li>Modificar el juego de Mini-Pong para ajustar su velocidad en tiempo real mediante botones.</li> </ul>"},{"location":"tarea_6/#3-requisitos","title":"3) Requisitos","text":"<p>Software - Visual Studio Code (Lenguaje de programaci\u00f3n C)</p> <p>Hardware - Raspberry Pi Pico 2 RP2350</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica</p>"},{"location":"tarea_6/#4-desarrollo","title":"4) Desarrollo","text":""},{"location":"tarea_6/#1-cuatro-alarmas","title":"1)  Cuatro alarmas","text":""},{"location":"tarea_6/#funcion","title":"Funci\u00f3n","text":"<p>Se controlan cuatro LEDs conectados a distintos pines, cada uno con una frecuencia propia. Al iniciar, todos los LEDs se configuran como salidas y permanecen apagados. Mediante intervalos predefinidos en microsegundos, cada LED cambia de estado de manera independiente cuando llega su turno, logrando parpadeos simult\u00e1neos pero a diferentes velocidades.</p>"},{"location":"tarea_6/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n#include \"hardware/gpio.h\"\n\n//\n#define LED0_GPIO 1   \n#define LED1_GPIO 0\n#define LED2_GPIO 2\n#define LED3_GPIO 3\n\n// Arreglo con los pines de los LEDs \nstatic const uint8_t pines_led[4] = { LED0_GPIO, LED1_GPIO, LED2_GPIO, LED3_GPIO };\n\n\nstatic const uint32_t intervalo_us[4] = {\n    300000u, // LED0_GPIO (GPIO 1): 300 ms\n    200000u, // LED1_GPIO (GPIO 0): 200 ms\n    120000u, // LED2_GPIO (GPIO 2): 120 ms\n     80000u  // LED3_GPIO (GPIO 3): 80 ms\n};\n\nstatic uint32_t proximo_toggle_us[4];\n\nint main(void) {\n    // Inicializo cada LED como salida y lo dejo apagado\n    for (int i = 0; i &lt; 4; ++i) {\n        gpio_init(pines_led[i]);\n        gpio_set_dir(pines_led[i], GPIO_OUT);\n        gpio_put(pines_led[i], 0);\n    }\n\n    // Punto de partida para todos los \"deadlines\"\n    uint32_t ahora_us = time_us_32();\n    for (int i = 0; i &lt; 4; ++i) {\n        proximo_toggle_us[i] = ahora_us + intervalo_us[i];\n    }\n\n    while (true) {\n        ahora_us = time_us_32();\n\n        // Recorro los 4 LEDs y verifico si \"ya es hora\" de togglear\n        for (int i = 0; i &lt; 4; ++i) {\n            if ((int32_t)(ahora_us - proximo_toggle_us[i]) &gt;= 0) {\n                // Toggle del LED i (XOR con su bit)\n                gpio_xor_mask(1u &lt;&lt; pines_led[i]);\n\n                // Rearme acumulativo del pr\u00f3ximo instante\n                proximo_toggle_us[i] += intervalo_us[i];\n            }\n        }\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"tarea_6/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_6/#video","title":"V\u00eddeo","text":""},{"location":"tarea_6/#2-mini-pong-con-velocidad-variable","title":"2) Mini-pong con velocidad variable","text":""},{"location":"tarea_6/#funcion_1","title":"Funci\u00f3n","text":"<p>Con ayuda de dos botones (BTN_J1 y BTN_J2) se controla la direcci\u00f3n de la \"pelota\" representada por un LED que se desplaza entre cinco posiciones. El juego inicia detenido y comienza cuando alguno de los jugadores presiona su bot\u00f3n. Si la pelota alcanza un extremo y no es golpeada, se activa un parpadeo en el LED del contrario para indicar el punto. Adem\u00e1s, se implementaron botones (BTN_M\u00c1S y BTN_MENOS) para aumentar o disminuir la velocidad del juego en tiempo real, as\u00ed como un bot\u00f3n de reinicio y un antirrebote.</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n\n#define BTN_J1 0   // Bot\u00f3n jugador izquierda\n#define BTN_J2 1   // Bot\u00f3n jugador derecha\n#define LED_J1 2   // LED indicador puntos J1\n#define LED_J2 3   // LED indicador puntos J2\n#define LED0 4     // Posici\u00f3n 0 de LED\n#define LED1 5\n#define LED2 6     // Centro de LEDs\n#define LED3 7\n#define LED4 8     // Posici\u00f3n 4 de LED\n#define RESET 9    // Bot\u00f3n de reinicio\n\n//  Botones NUEVOS \n#define BTN_MAS   10  // Subir velocidad\n#define BTN_MENOS 11  // Bajar velocidad\n\n//  Alarmas del timer\n#define ALARMA_JUEGO_NUM  0  // tick de juego\n#define ALARMA_PUNTO_NUM  1  // parpadeo de punto\n#define IRQ_ALARMA_JUEGO  timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_JUEGO_NUM)\n#define IRQ_ALARMA_PUNTO  timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_PUNTO_NUM)\n\n//  Velocidades (ms) \n#define VEL_PELOTA 100\n#define VEL_REBOTE 300\n\n// Rango y paso de velocidad (us)\n#define VEL_MIN_US        40000u\n#define VEL_MAX_US       400000u\n#define VEL_PASO_US       20000u   // salto entre us\n#define ANTIRREBOTE_VEL_US 120000u // antirrebote para botones de velocidad\n\nuint8_t POS = LED2;     // Pelota arranca en el centro\nbool DIR = 1;           // 1 = derecha, 0 = izquierda\nbool START = false;     // Juego detenido al inicio\n\nvolatile bool GOLPE_J1 = false;\nvolatile bool GOLPE_J2 = false;\nvolatile bool START_J1 = false;\nvolatile bool START_J2 = false;\nvolatile bool RESET_STATE = false;\n\n//  M\u00e1scaras \nuint32_t LEDS_MASK;                   \nstatic uint32_t MASCARA_LEDS_POS;     // solo LEDs de posici\u00f3n, no marca\n\n//  Tiempo y tick \nstatic inline uint32_t microsegundos(void){ return timer_hw-&gt;timerawl; }\nstatic volatile uint32_t VEL_PELOTA_US = (uint32_t)VEL_PELOTA * 1000u; // periodo del tick en \u00b5s\nstatic volatile uint32_t PROXIMO_TICK_US = 0;\nstatic volatile uint32_t ULTIMO_CAMBIO_VEL_US = 0; // antirrebote de BTN_MAS/BTN_MENOS\n\n//  Ventana de rebote fija en tiempo \n#define REBOTE_US ((uint32_t)VEL_REBOTE * 1000u)\nstatic volatile bool EN_PARED = false;\nstatic volatile uint32_t VENTANA_HASTA_US = 0;\n\n//  Parpadeo no bloqueante (ALARMA_PUNTO)\nstatic volatile bool PARPADEO_ACTIVO = false;\nstatic volatile uint8_t  PIN_LED_PARPADEO = 0;\nstatic volatile uint8_t  PARPADEOS_RESTANTES = 0;\nstatic volatile uint32_t PROXIMO_PARPADEO_US = 0;\n#define PARPADEO_MEDIO_US 200000u // 200 ms ON/OFF\n\n//  Prototipos requeridos \nstatic void PONG(uint PIN, uint32_t EVENT_MASK);\nvoid BLINK(uint8_t LED);\nvoid REINICIAR();\nvoid MOVER_PELOTA(void);\n\n// ---- ISRs de alarmas \nstatic void irq_alarma_juego(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_JUEGO_NUM);\n    MOVER_PELOTA();\n    PROXIMO_TICK_US += VEL_PELOTA_US;\n    timer_hw-&gt;alarm[ALARMA_JUEGO_NUM] = PROXIMO_TICK_US;\n}\n\nstatic void irq_alarma_punto(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_PUNTO_NUM);\n\n    if (!PARPADEO_ACTIVO || PARPADEOS_RESTANTES == 0){\n        gpio_put(PIN_LED_PARPADEO, 0);\n        PARPADEO_ACTIVO = false;\n        return;\n    }\n    sio_hw-&gt;gpio_togl = (1u &lt;&lt; PIN_LED_PARPADEO);\n    PARPADEOS_RESTANTES--;\n    PROXIMO_PARPADEO_US += PARPADEO_MEDIO_US;\n    timer_hw-&gt;alarm[ALARMA_PUNTO_NUM] = PROXIMO_PARPADEO_US;\n}\n\nint main() {\n    // LEDs\n    LEDS_MASK = (1u &lt;&lt; LED_J1) | (1u &lt;&lt; LED_J2) | (1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) |\n                (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4);\n    MASCARA_LEDS_POS = (1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4);\n\n    gpio_init_mask(LEDS_MASK);\n    gpio_set_dir_masked(LEDS_MASK, LEDS_MASK);\n    gpio_clr_mask(LEDS_MASK);\n\n    // Botones \n    gpio_init(BTN_J1);   gpio_set_dir(BTN_J1, GPIO_IN);   gpio_pull_up(BTN_J1);\n    gpio_init(BTN_J2);   gpio_set_dir(BTN_J2, GPIO_IN);   gpio_pull_up(BTN_J2);\n    gpio_init(RESET);    gpio_set_dir(RESET,  GPIO_IN);   gpio_pull_up(RESET);\n    gpio_init(BTN_MAS);  gpio_set_dir(BTN_MAS, GPIO_IN);  gpio_pull_up(BTN_MAS);\n    gpio_init(BTN_MENOS);gpio_set_dir(BTN_MENOS, GPIO_IN);gpio_pull_up(BTN_MENOS);\n\n    gpio_set_mask(1u &lt;&lt; POS); // LED inicial en centro\n\n    // IRQ GPIO por flanco de bajada \n    gpio_set_irq_enabled_with_callback(BTN_J1, GPIO_IRQ_EDGE_FALL, true, &amp;PONG);\n    gpio_set_irq_enabled(BTN_J2,   GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(RESET,    GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(BTN_MAS,  GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(BTN_MENOS,GPIO_IRQ_EDGE_FALL, true);\n\n    // Timer de sistema en \u00b5s\n    timer_hw-&gt;source = 0u;\n    uint32_t ahora = microsegundos();\n\n    // Programa ALARMA_JUEGO (primer tick)\n    PROXIMO_TICK_US = ahora + VEL_PELOTA_US;\n    timer_hw-&gt;alarm[ALARMA_JUEGO_NUM] = PROXIMO_TICK_US;\n\n    // Limpia flags, registra handlers y habilita\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARMA_JUEGO_NUM) | (1u &lt;&lt; ALARMA_PUNTO_NUM));\n    irq_set_exclusive_handler(IRQ_ALARMA_JUEGO,  irq_alarma_juego);\n    irq_set_exclusive_handler(IRQ_ALARMA_PUNTO,  irq_alarma_punto);\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARMA_JUEGO_NUM) | (1u &lt;&lt; ALARMA_PUNTO_NUM));\n    irq_set_enabled(IRQ_ALARMA_JUEGO,  true);\n    irq_set_enabled(IRQ_ALARMA_PUNTO,  true);\n\n    while (true) { tight_loop_contents(); }\n}\n\n// ---- ISR GPIO \nstatic void PONG(uint PIN, uint32_t EVENT_MASK) {\n    if (EVENT_MASK &amp; GPIO_IRQ_EDGE_FALL) {\n        if (PIN == BTN_J1) {\n            if (!START) START_J1 = true;\n            else if (POS == LED0) GOLPE_J1 = true;\n        } else if (PIN == BTN_J2) {\n            if (!START) START_J2 = true;\n            else if (POS == LED4) GOLPE_J2 = true;\n        } else if (PIN == RESET) {\n            RESET_STATE = true;\n        } else if (PIN == BTN_MAS || PIN == BTN_MENOS) {\n            uint32_t t = microsegundos();\n            // antirrebote botones de velocidad\n            if ((int32_t)(t - ULTIMO_CAMBIO_VEL_US) &gt; (int32_t)ANTIRREBOTE_VEL_US) {\n                if (PIN == BTN_MAS) {\n                    // m\u00e1s r\u00e1pido = menor periodo\n                    if (VEL_PELOTA_US &gt; VEL_MIN_US + VEL_PASO_US - 1) VEL_PELOTA_US -= VEL_PASO_US;\n                    else VEL_PELOTA_US = VEL_MIN_US;\n                } else {\n                    // m\u00e1s lento = mayor periodo\n                    if (VEL_PELOTA_US &lt; VEL_MAX_US - VEL_PASO_US + 1) VEL_PELOTA_US += VEL_PASO_US;\n                    else VEL_PELOTA_US = VEL_MAX_US;\n                }\n                // re-alinear pr\u00f3ximo tick para notar el cambio de inmediato\n                PROXIMO_TICK_US = t + VEL_PELOTA_US;\n                timer_hw-&gt;alarm[ALARMA_JUEGO_NUM] = PROXIMO_TICK_US;\n                ULTIMO_CAMBIO_VEL_US = t;\n            }\n        }\n    }\n    gpio_acknowledge_irq(PIN, EVENT_MASK);\n}\n\n//  BLINK del original: ahora inicia parpadeo no bloqueante\nvoid BLINK(uint8_t LED) {\n    PIN_LED_PARPADEO = LED;\n    PARPADEOS_RESTANTES = 6; // 3 destellos ON/OFF\n    gpio_put(PIN_LED_PARPADEO, 0);\n    PARPADEO_ACTIVO = true;\n    PROXIMO_PARPADEO_US = microsegundos() + PARPADEO_MEDIO_US;\n    timer_hw-&gt;alarm[ALARMA_PUNTO_NUM] = PROXIMO_PARPADEO_US;\n}\n\nvoid REINICIAR() {\n    POS = LED2;\n    START = false;\n    GOLPE_J1 = false;\n    GOLPE_J2 = false;\n    START_J1 = false;\n    START_J2 = false;\n    EN_PARED = false;\n    PARPADEO_ACTIVO = false;\n    gpio_put(LED_J1, 0);\n    gpio_put(LED_J2, 0);\n    gpio_clr_mask(MASCARA_LEDS_POS);\n    gpio_set_mask(1u &lt;&lt; POS); // LED centro\n}\n\nvoid MOVER_PELOTA() {\n    uint32_t tnow = microsegundos();\n\n    if (RESET_STATE) {\n        REINICIAR();\n        RESET_STATE = false;\n        return;\n    }\n\n    if (!START) {\n        if (START_J1) { DIR = 1; START = true; START_J1 = false; }\n        else if (START_J2) { DIR = 0; START = true; START_J2 = false; }\n        gpio_set_mask(1u &lt;&lt; POS); // LED centro\n        return;\n    }\n\n    // Ventana fija cuando est\u00e1 en pared\n    if (EN_PARED) {\n        if ((int32_t)(tnow - VENTANA_HASTA_US) &gt;= 0) {\n            if (POS == LED0) {\n                if (GOLPE_J1) { DIR = 1; }\n                else { BLINK(LED_J2); POS = LED2; DIR = 1; START = true; }\n                GOLPE_J1 = false;\n            } else if (POS == LED4) {\n                if (GOLPE_J2) { DIR = 0; }\n                else { BLINK(LED_J1); POS = LED2; DIR = 0; START = true; }\n                GOLPE_J2 = false;\n            }\n            EN_PARED = false;\n            gpio_clr_mask(MASCARA_LEDS_POS);\n            gpio_set_mask(1u &lt;&lt; POS);\n        }\n        return; // mientras dura la ventana no se mueve\n    }\n\n    // Mover pelota 1 paso\n    if (DIR &amp;&amp; POS &lt; LED4) POS++;\n    else if (!DIR &amp;&amp; POS &gt; LED0) POS--;\n\n    // Si lleg\u00f3 a pared, abrir ventana\n    if (POS == LED0 || POS == LED4) {\n        EN_PARED = true;\n        VENTANA_HASTA_US = tnow + REBOTE_US;\n    }\n\n    gpio_clr_mask(MASCARA_LEDS_POS);\n    gpio_set_mask(1u &lt;&lt; POS);\n}\n</code></pre>"},{"location":"tarea_6/#esquematico-de-conexion_1","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_6/#video_1","title":"V\u00eddeo","text":""},{"location":"tarea_7/","title":"Modulaci\u00f3n por ancho de pulso - PWM","text":""},{"location":"tarea_7/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Modulaci\u00f3n por ancho de pulso - PWM </li> <li>Equipo: Carlos Ernesto Camacho Gonzalez y David L\u00f3pez Ram\u00edrez </li> <li>Curso: Sistemas Embebidos I </li> <li>Fecha: 30/09/2025 </li> <li>Descripci\u00f3n breve: Estas pr\u00e1cticas muestran aplicaciones pr\u00e1cticas de la generaci\u00f3n de frecuencias: control de velocidad de un motor mediante el PWM, generaci\u00f3n de notas con un buzzer variando la frecuencia, y s\u00edntesis de una se\u00f1al senoidal de 60 Hz mediante PWM m\u00e1s un filtro RC.</li> </ul>"},{"location":"tarea_7/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Aplicar la modulaci\u00f3n por ancho de pulso (PWM) en diferentes contextos de control y generaci\u00f3n de se\u00f1ales, integrando componentes electr\u00f3nicos y de programaci\u00f3n.</li> <li>Espec\u00edficos:</li> <li>Implementar circuitos y programas que regulen velocidad de motores DC y generen tonos musicales con un buzzer mediante variaci\u00f3n de duty cycle y frecuencia.</li> </ul>"},{"location":"tarea_7/#3-requisitos","title":"3) Requisitos","text":"<p>Software - Visual Studio Code (Lenguaje de programaci\u00f3n C)</p> <p>Hardware - Raspberry Pi Pico 2 RP2350</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica</p>"},{"location":"tarea_7/#4-desarrollo","title":"4) Desarrollo","text":""},{"location":"tarea_7/#1-control-de-duty-cycle-motor-dc","title":"1)  Control de Duty Cycle \u2014 Motor DC","text":""},{"location":"tarea_7/#funcion","title":"Funci\u00f3n","text":"<p>Se configura un pin PWM para controlar un motor DC y utiliza dos botones para cambiar entre tres valores de duty cycle (baja, media y alta velocidad). Con cada pulsaci\u00f3n se actualiza la velocidad seleccionada.</p>"},{"location":"tarea_7/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n// PWM \n#define MOTOR_PWM_PIN   0\n// Bot\u00f3n para subir velocidad\n#define BTN_UP          1\n// Bot\u00f3n para bajar velocidad\n#define BTN_DOWN        2\n// Direcci\u00f3n del motor\n#define MOTOR_DIR_PIN   3\n\n//Configuraci\u00f3n de PWM \n#define F_PWM_HZ 2000   // 2 kHz\n#define TOP 1023        // 10 bits de resoluci\u00f3n (0-1023)\n\nint main() {\n    stdio_init_all();\n\n    // Habilitar la funci\u00f3n PWM\n    gpio_set_function(MOTOR_PWM_PIN, GPIO_FUNC_PWM);\n\n\n    gpio_init(MOTOR_DIR_PIN);\n    gpio_set_dir(MOTOR_DIR_PIN, GPIO_OUT);\n    gpio_put(MOTOR_DIR_PIN, 1); \n\n    gpio_init(BTN_UP);\n    gpio_set_dir(BTN_UP, GPIO_IN);\n    gpio_pull_up(BTN_UP);\n\n    gpio_init(BTN_DOWN);\n    gpio_set_dir(BTN_DOWN, GPIO_IN);\n    gpio_pull_up(BTN_DOWN);\n\n    // Configuraci\u00f3n de hardware PWM \n    uint slice = pwm_gpio_to_slice_num(MOTOR_PWM_PIN);\n    uint chan  = pwm_gpio_to_channel(MOTOR_PWM_PIN);\n\n    // Calcular divisor de reloj para la frecuencia deseada\n    float f_clk = 125000000.0f; // Reloj del sistema es 125 MHz\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n\n    // Establecer el valor m\u00e1ximo del contador O SEA resolucion\n    pwm_set_wrap(slice, TOP);\n\n    // Iniciar PWM con el motor apagado\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n\n    int speed_level = 0;\n    // Duty cycles \n    const uint16_t duty_levels[] = {0, 307, 665, 972}; \n\n    while (true) {\n\n        if (!gpio_get(BTN_UP)) {\n            if (speed_level &lt; 3) { \n                speed_level++;\n            }\n            pwm_set_chan_level(slice, chan, duty_levels[speed_level]);\n            sleep_ms(200);\n        }\n\n        if (!gpio_get(BTN_DOWN)) {\n            if (speed_level &gt; 0) { \n                speed_level--;\n            }\n            pwm_set_chan_level(slice, chan, duty_levels[speed_level]);\n            sleep_ms(200);\n        }\n    }\n}\n</code></pre>"},{"location":"tarea_7/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_7/#video","title":"V\u00eddeo","text":""},{"location":"tarea_7/#2-control-de-frecuencia-cancion-con-buzzer","title":"2) Control de Frecuencia \u2014 Canci\u00f3n con Buzzer","text":""},{"location":"tarea_7/#funcion_1","title":"Funci\u00f3n","text":"<p>Genera una melod\u00eda en un buzzer variando la frecuencia del PWM mientras mantiene un duty fijo de 50 %. Para ello recorre una tabla de notas con frecuencias y duraciones, reproduciendo cada una con pausas definidas para hacer la melod\u00eda clara.</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZZER_PIN 0\n\n#define TOP 1023        // Resoluci\u00f3n\n#define TEMPO 190       // Tempo muy r\u00e1pido\n\n//Duraciones de Nota\n#define NEGRA (60000 / TEMPO)\n#define CORCHEA (NEGRA / 2)\n#define SEMICORCHEA (NEGRA / 4)\n\nint main() {\n    stdio_init_all();\n    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);\n\n    uint slice = pwm_gpio_to_slice_num(BUZZER_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZZER_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0); // Empezar en silencio\n    pwm_set_enabled(slice, true);\n\n    // Pac-Man\n    const float frecuencias[] = {\n        //Intro Original\n        987.77, 1479.98, 1244.51, 987.77, 1479.98, 1244.51, 0,\n        1046.50, 1567.98, 1318.51, 1046.50, 1567.98, 1318.51, 0,\n        987.77, 880.00, 783.99, 698.46, 622.25, 587.33, 0,\n\n        //Intermisi\u00f3n\n        783.99, 0, 880.00, 0, 987.77, 0, 783.99,\n        987.77, 0, 1046.50, 0, 1174.66, 0, 987.77,\n        1174.66, 0, 1244.51, 0, 1318.51, 0, 1174.66\n    };\n\n    const int duraciones[] = {\n        // Duraciones Intro\n        CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA,\n        CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA,\n        SEMICORCHEA, SEMICORCHEA, SEMICORCHEA, SEMICORCHEA, SEMICORCHEA, NEGRA, NEGRA,\n\n        // Duraciones Intermisi\u00f3n\n        CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, NEGRA,\n        CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, NEGRA,\n        CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, NEGRA\n    };\n\n    int num_notas = sizeof(frecuencias) / sizeof(frecuencias[0]);\n\n    while(true) {\n        // Tocar la melod\u00eda completa\n        for (int i = 0; i &lt; num_notas; i++) {\n            if (frecuencias[i] &gt; 0) {\n                float f_clk = 125000000.0f;\n                float div = f_clk / (frecuencias[i] * (TOP + 1));\n                pwm_set_clkdiv(slice, div);\n                pwm_set_chan_level(slice, chan, TOP / 2);\n            } else {\n                pwm_set_chan_level(slice, chan, 0);\n            }\n            sleep_ms(duraciones[i]);\n        }\n        pwm_set_chan_level(slice, chan, 0);\n        sleep_ms(2000); // Pausa de 2 segundos\n    }\n}\n</code></pre>"},{"location":"tarea_7/#esquematico-de-conexion_1","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_7/#video_1","title":"V\u00eddeo","text":""},{"location":"tarea_7/#3-generacion-de-senales-senoidal-de-60-hz-con-pwm-filtro-rc","title":"3) Generaci\u00f3n de Se\u00f1ales \u2014 Senoidal de 60 Hz con PWM + Filtro RC","text":""},{"location":"tarea_7/#funcion_2","title":"Funci\u00f3n","text":"<p>Produce una se\u00f1al senoidal aproximada de 60 Hz modulando el duty cycle del PWM de acuerdo con una funci\u00f3n seno, donde la salida se pasa por un filtro RC. Comparando la se\u00f1al generada antes y despu\u00e9s de la aplicaci\u00f3n del filtro RC con ayuda de un osciloscopio.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define SENAL 0          // Pin GPIO de salida\n#define TOP 1023         // Resoluci\u00f3n del PWM (10 bits)\n#define FREQ 60          // Frecuencia de la se\u00f1al senoidal deseada (Hz)\n#define TAMANO_SENO 100     // N\u00famero de puntos de la tabla seno\n\n// Tabla seno (se llenar\u00e1 en tiempo de ejecuci\u00f3n)\nuint16_t TABLA_SENO[TAMANO_SENO];\n\nint main() {\n    stdio_init_all();\n\n    // Llenar tabla seno con VALores escalados a [0, TOP]\n    for (uint8_t i = 0; i &lt; TAMANO_SENO; i++) {\n        double RAD = (2 * M_PI * i) / TAMANO_SENO;\n        double VAL = (sin(RAD) + 1.0) / 2.0;\n        TABLA_SENO[i] = (uint16_t)(VAL * TOP);\n    }\n\n    // Configurar pin PWM\n    gpio_set_function(SENAL, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SENAL);\n    uint chan = pwm_gpio_to_channel(SENAL);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    // Calcular la frecuencia de actualizaci\u00f3n de la LUT\n    // Se necesita actualizar TAMANO_SENO veces por cada ciclo de 60 Hz\n    double RATE = FREQ * TAMANO_SENO;  // Hz\n    uint32_t delay_us = 1000000.0 / RATE;\n\n    int INDEX = 0;\n    while (true) {\n        pwm_set_chan_level(slice, chan, TABLA_SENO[INDEX]);\n\n        INDEX++;\n        if (INDEX &gt;= TAMANO_SENO) INDEX = 0;\n\n        sleep_us(delay_us);  // Espera para ajustar la frecuencia\n    }\n}\n</code></pre>"},{"location":"tarea_7/#esquematico-de-conexion_2","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_7/#senal-pwm-sin-filtro-rc","title":"Se\u00f1al PWM sin filtro RC","text":""},{"location":"tarea_7/#senal-pwm-con-filtro-rc","title":"Se\u00f1al PWM con filtro RC","text":""},{"location":"tarea_8/","title":"Outpus b\u00e1sicos","text":""},{"location":"tarea_8/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Comunicaci\u00f3n Serial - UART </li> <li>Equipo: Carlos Ernesto Camacho Gonzalez, David L\u00f3pez Ram\u00edrez, Rodrigo Miranda Flores y Luis Javier Vega Tello </li> <li>Curso: Sistemas Embebidos I </li> <li>Fecha: 12/10/2025 </li> <li>Descripci\u00f3n breve: Introducci\u00f3n a la comunicaci\u00f3n serial UART.</li> </ul>"},{"location":"tarea_8/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender la programaci\u00f3n b\u00e1sica para la comunicaci\u00f3n serial UART.</li> </ul>"},{"location":"tarea_8/#3-requisitos","title":"3) Requisitos","text":"<p>Software - Visual Studio Code (Lenguaje de programaci\u00f3n C)</p> <p>Hardware - Raspberry Pi Pico 2 RP2350</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica</p>"},{"location":"tarea_8/#4-desarrollo","title":"4) Desarrollo","text":""},{"location":"tarea_8/#1-comunicacion-serial-uart","title":"1)  Comunicaci\u00f3n Serial UART","text":""},{"location":"tarea_8/#funcion","title":"Funci\u00f3n","text":"<p>Con un boton conectado a una RP2350 se controla el encendido y apagado de un led conectada a otra RP2350\u00a0y\u00a0viceversa.</p>"},{"location":"tarea_8/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n\n#define UART_ID uart0\n#define BAUD_RATE 9600\n\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n\n#define LED_PIN 15\n#define BUTTON_PIN 14\n\nint main() {\n    stdio_init_all();\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    gpio_init(BUTTON_PIN);\n    gpio_set_dir(BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(BUTTON_PIN);\n\n    bool last_button_state = true;\n    bool led_state = false;\n\n    while (true) {\n        bool button_state = gpio_get(BUTTON_PIN);\n\n        // Si se detecta una pulsaci\u00f3n (de HIGH a LOW)\n        if (last_button_state &amp;&amp; !button_state) {\n            uart_putc(UART_ID, 'T'); // Enviamos el car\u00e1cter 'T' al otro Pico\n            sleep_ms(200); // anti rebote\n        }\n        last_button_state = button_state;\n\n        // Si se recibe un byte por UART\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == 'T') {\n                led_state = !led_state; // Cambiar estado del LED\n                gpio_put(LED_PIN, led_state);\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"tarea_8/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_8/#video","title":"V\u00eddeo","text":""},{"location":"tarea_8/#2-comunicacion-serial-uart-comandos","title":"2)  Comunicaci\u00f3n Serial UART - Comandos","text":""},{"location":"tarea_8/#funcion_1","title":"Funci\u00f3n","text":"<p>Con un boton conectado a una RP2350 se controla el encendido y apagado de un led conectada a otra RP2350, el RP2350 emisor manda una cadena de caracteres que recibe el RP2350 receptor. Adem\u00e1s, se configur\u00f3 el envi\u00f3 de comandos mediante la comunicaci\u00f3n serial de la computadora.</p>"},{"location":"tarea_8/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define BUTTON_PIN 14\n#define LED_PIN 15\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    gpio_init(BUTTON_PIN);\n    gpio_set_dir(BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(BUTTON_PIN);\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    string c = \"\";\n    string p=\"\";\n    while (true){\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            p+= (char)ch;\n            if(ch=='.' || ch=='\\n'){\n                uart_puts(UART_ID, p.c_str());\n                p=\"\";\n            }\n        }\n        int a;\n        if (gpio_get(BUTTON_PIN) == 0 &amp;&amp; a == 1) {\n            printf(\"Button pressed!\\n\");\n            uart_puts(UART_ID, \"LEDON\\n\");\n            sleep_ms(200); \n        }\n         a= gpio_get(BUTTON_PIN);\n\n        if (uart_is_readable(uart0)) {\n            char character = uart_getc(uart0);\n            printf(character+\"\\n\");\n            if(character=='\\n' || character=='.'){\n                if (c == \"LEDON\"){\n                    gpio_put(LED_PIN, 1);\n                    printf(\"LED is ON\\n\");\n                }\n                else if (c == \"LEDOFF\"){\n                    gpio_put(LED_PIN, 0);\n                    printf(\"LED is OFF\\n\");\n                } else if(c==\"Invalid Command\"){\n                    printf(\"Invalid Command\\n\");\n                }\n                else{\n                    uart_puts(UART_ID, \"Invalid Command\\n\");\n                }\n                c = \"\";\n                continue;\n            }\n            else{\n                c += character;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"tarea_8/#esquematico-de-conexion_1","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_8/#video_1","title":"V\u00eddeo","text":""},{"location":"tarea_9/","title":"Convertidor anal\u00f3gico a digital","text":""},{"location":"tarea_9/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Convertidor anal\u00f3gico a digital </li> <li>Equipo: Carlos Ernesto Camacho Gonzalez, David L\u00f3pez Ram\u00edrez, Rodrigo Miranda Flores y Luis Javier Vega Tello </li> <li>Curso: Sistemas Embebidos I </li> <li>Fecha: 06/11/2025 </li> <li>Descripci\u00f3n breve: Se realizaron practicas de conversi\u00f3n anal\u00f3gico a digital</li> </ul>"},{"location":"tarea_9/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Comprender el conversor anal\u00f3gico a digital.</li> </ul>"},{"location":"tarea_9/#3-requisitos","title":"3) Requisitos","text":"<p>Software - Visual Studio Code (Lenguaje de programaci\u00f3n C)</p> <p>Hardware - Raspberry Pi Pico 2 RP2350</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica</p>"},{"location":"tarea_9/#4-desarrollo","title":"4) Desarrollo","text":""},{"location":"tarea_9/#1-adc-luxometro","title":"1)  ADC Luxometro","text":""},{"location":"tarea_9/#funcion","title":"Funci\u00f3n","text":"<p>Con ayuda de unn c\u00f3digo se marca la luminosidad de 0-100% usando un LDR.</p>"},{"location":"tarea_9/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n\n// Configurar el canal ADC a usar\n#define ADC_INPUT 0 // canal 0\n\n#define ADC_MIN 850    // valor cuando tapas la LDR\n#define ADC_MAX 3100   // valor con luz m\u00e1xima\n\nint main() {\n    stdio_init_all();\n    adc_init();\n    // Configura el pin GPIO correspondiente como entrada ADC\n    adc_gpio_init(26); // GPIO26 suele mapear a ADC0 en Pico 2\n    // Seleccionar canal\n    adc_select_input(ADC_INPUT);\n\n    while (true) {\n        uint16_t adc = adc_read(); // 12 bits alineados a 0..4095\n\n        if (adc &lt; ADC_MIN) adc = ADC_MIN;\n        if (adc &gt; ADC_MAX) adc = ADC_MAX;\n\n        // Calcular porcentaje de luz 0\u2013100\n        float luz = (adc - ADC_MIN) * 100.0f / (ADC_MAX - ADC_MIN);\n\n        printf(\"ADC: %u\\tLuz: %.1f%%\\n\", adc, luz);\n        sleep_ms(200);\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre>"},{"location":"tarea_9/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_9/#video","title":"V\u00eddeo","text":"<p>https://www.youtube.com/shorts/VtgWAUczVmI</p>"},{"location":"tarea_9/#2-servo-con-adc","title":"2) Servo con ADC","text":""},{"location":"tarea_9/#funcion_1","title":"Funci\u00f3n","text":"<p>Se crea un c\u00f3digo para mover un servo usando un potenciometro y un adc que vaya 0-180 grados</p> <pre><code>#include &lt;iostream&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/pwm.h\"\n\nusing namespace std;\n\n#define SERVO_PIN 0    \n#define POT_PIN 26      \n\nint main() {\n    stdio_init_all();\n\n   //inicializar ADC\n    adc_init();\n    adc_gpio_init(POT_PIN);\n    adc_select_input(0);\n    adc_set_clkdiv(479.0f);          \n    adc_fifo_setup(true, false, 1, false, false);  \n    adc_fifo_drain();                \n    adc_run(true);                    \n\n   //inicializar PWM para el servo\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice_num = pwm_gpio_to_slice_num(SERVO_PIN); //aplicar configuracion al slice\n\n    pwm_set_clkdiv(slice_num, 64.0f);\n    pwm_set_wrap(slice_num, 39062);  \n//ajustar frecuencia del pwm\n    pwm_set_enabled(slice_num, true);\n\n    while (true) {\n\n        if (adc_fifo_get_level() &gt; 0) { //para ver si hay algo dentro del fifo\n            uint16_t valor_adc = adc_fifo_get();\n\n\n            float duty = 0.025f + (valor_adc / 4095.0f) * 0.1f;\n\n            pwm_set_gpio_level(SERVO_PIN, duty * 39062);\n\n\n        }\n\n        sleep_ms(20);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"tarea_9/#esquematico-de-conexion_1","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"tarea_9/#video_1","title":"V\u00eddeo","text":"<p>https://www.youtube.com/shorts/L8Vw-Pges6I</p>"}]}